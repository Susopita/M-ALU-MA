
module SumSub #(
    // ✅ PARÁMETROS PRINCIPALES: Ancho de Exponente y Mantisa
    parameter E_BITS = 8,
    parameter M_BITS = 23
) (
    // ✅ PUERTOS GENÉRICOS: El ancho total se calcula automáticamente
    input [1+E_BITS+M_BITS-1:0] A, B,
    input                       op,
    output reg [1+E_BITS+M_BITS-1:0] Result,
    output reg [4:0]                 ALUFlags
);
    // =================================================================
    // ✅ PARÁMETROS LOCALES (calculados a partir de los principales)
    // =================================================================
    localparam BITS = 1 + E_BITS + M_BITS;
    localparam EXP_MAX = {E_BITS{1'b1}};
    // Ancho para la mantisa extendida: {Overflow, Implícito, Mantisa, G, R, S}
    localparam MANT_EXT_WIDTH = M_BITS + 5;

    // =================================================================
    // ✅ DECONSTRUCCIÓN PARAMETRIZADA
    // =================================================================
    wire s_A = A[BITS-1];
    wire [E_BITS-1:0] e_A = A[BITS-2 : M_BITS];
    wire [M_BITS-1:0] m_A = A[M_BITS-1 : 0];

    wire s_B = B[BITS-1];
    wire [E_BITS-1:0] e_B = B[BITS-2 : M_BITS];
    wire [M_BITS-1:0] m_B = B[M_BITS-1 : 0];

    wire effective_s_B = op ? ~s_B : s_B;
    
    // =================================================================
    // ✅ REGISTROS INTERNOS PARAMETRIZADOS
    // =================================================================
    reg s_C;
    reg [E_BITS-1:0] e_C;
    reg [MANT_EXT_WIDTH-1:0] m_C; // Usa el ancho extendido calculado

    reg [MANT_EXT_WIDTH-1:0] m_A_full, m_B_full;

    integer i;
    reg [$clog2(M_BITS+1)-1:0] zeros = 0; // Ancho calculado para 'zeros'

    reg [E_BITS-1:0] shift_amount; // Ancho calculado para 'shift_amount'
    reg R_bit, S_bit;
    reg round_up;
    reg [MANT_EXT_WIDTH-1:0] sticky_mask;

    // ✅ Registros para cada flag
    reg flag_invalid, flag_div_zero, flag_overflow, flag_underflow, flag_inexact;

    // =================================================================
    // ✅ DETECCIÓN DE CASOS ESPECIALES PARAMETRIZADA
    // =================================================================
    wire is_zero_A = (e_A == 0 && m_A == 0);
    wire is_inf_A  = (e_A == EXP_MAX && m_A == 0);
    wire is_nan_A  = (e_A == EXP_MAX && m_A != 0);

    wire is_zero_B = (e_B == 0 && m_B == 0);
    wire is_inf_B  = (e_B == EXP_MAX && m_B == 0);
    wire is_nan_B  = (e_B == EXP_MAX && m_B != 0);
    // Sumar
    always @(*) begin

        // ✅ Inicializar flags a 0 en cada ciclo
        flag_invalid = 1'b0;
        flag_div_zero = 1'b0; // Siempre 0 para suma/resta
        flag_overflow = 1'b0;
        flag_underflow = 1'b0;
        flag_inexact = 1'b0;
 
        // =================================================================
        // ✅ APLICAR LAS REGLAS DE LA ARITMÉTICA ESPECIAL
        // =================================================================
        // La lógica de prioridad es: NaN > Infinito > Cero > Normal

        // --- MANEJO DE CASOS ESPECIALES ---
        if (is_nan_A || is_nan_B) begin
            Result = {1'b0, EXP_MAX, {1'b1, {M_BITS-1{1'b0}}}}; // NaN genérico
            flag_invalid = 1'b1;
        end else if (is_inf_A) begin
            if (is_inf_B && (s_A != effective_s_B)) begin
                Result = {1'b0, EXP_MAX, {1'b1, {M_BITS-1{1'b0}}}}; // NaN
                flag_invalid = 1'b1;
            end else Result = A;
        end else if (is_inf_B) begin
            Result = {effective_s_B, EXP_MAX, {M_BITS{1'b0}}};
        end else if (is_zero_A) begin
            Result = {effective_s_B, e_B, m_B};
        end else if (is_zero_B) begin
            Result = A;
        end else begin

            // ==============================
            // Inicializacion
            // ==============================

            m_A_full = {2'b01, m_A, 3'b000};
            m_B_full = {2'b01, m_B, 3'b000};

            // Nivelar exponentes
            if (e_A > e_B) begin
                shift_amount = e_A - e_B;
                e_C = e_A;
                // Para calcular R y S, creamos un 'sticky_mask'
                // El 'OR' de los bits que se caerán (excepto el primero) será el Sticky Bit.
                if (shift_amount > 0) begin
                    R_bit = m_B_full[shift_amount - 1 + 3];
                    sticky_mask = (1 << shift_amount) - 1;
                    S_bit = |(m_B_full & sticky_mask);
                end
                m_B_full >>= shift_amount;
            end 
            else if (e_B > e_A) begin
                shift_amount = e_B - e_A;
                e_C = e_B;
                if (shift_amount > 0) begin
                    R_bit = m_A_full[shift_amount - 1 + 3];
                    sticky_mask = (1 << shift_amount) - 1;
                    S_bit = |(m_A_full & sticky_mask);
                end
                m_A_full >>= shift_amount;
            end else begin
                e_C = e_A; // Exponentes ya son iguales
            end

            // Sumar mantisas
            if (s_A == effective_s_B) begin
                m_C = m_A_full + m_B_full;
                s_C = s_A;
            end
            else if (m_A_full >= m_B_full) begin
                m_C = m_A_full - m_B_full;
                s_C = s_A;
            end else begin
                m_C = m_B_full - m_A_full;
                s_C = s_B;
            end


            // ✅ FLAG: Si se perdieron bits en la alineación, el resultado será inexacto
            if (R_bit || S_bit) begin
                flag_inexact = 1'b1;
            end
            

            // --- NORMALIZACIÓN, REDONDEO Y ENSAMBLADO FINAL ---
            if (m_C == 0) begin
                s_C = 1'b0; // x-x siempre es +0
                e_C = 0;
                Result = {s_C, {E_BITS{1'b0}}, {M_BITS{1'b0}}};
            end else begin
                // NORMALIZACIÓN
                if (m_C[M_BITS+4]) begin // Overflow de mantisa
                    R_bit = m_C[0]; S_bit = R_bit | S_bit;
                    m_C = m_C >> 1;
                    e_C = e_C + 1;
                end else if (~m_C[M_BITS+3]) begin // Leading zeros
                    zeros = 0;
                    for (i = M_BITS+2; i >= 3; i = i - 1) begin
                        if (m_C[i]) zeros = (M_BITS+3) - i;
                    end
                    if (e_C > zeros) begin
                        m_C = m_C << zeros;
                        e_C = e_C - zeros;
                    end else begin
                        flag_underflow = 1'b1; flag_inexact = 1'b1;
                        m_C = 0; e_C = 0;
                    end
                end

                // REDONDEO
                round_up = R_bit && (S_bit || m_C[3]);
                if (round_up) begin
                    flag_inexact = 1'b1;
                    m_C = m_C + (1 << 3);
                    if (m_C[M_BITS+4]) begin
                        m_C = m_C >> 1;
                        e_C = e_C + 1;
                    end
                end

                // CHEQUEO FINAL y ENSAMBLADO
                if (e_C >= EXP_MAX) begin
                    flag_overflow = 1'b1; flag_inexact = 1'b1;
                    Result = {s_C, EXP_MAX, {M_BITS{1'b0}}};
                end else begin
                    Result = {s_C, e_C, m_C[M_BITS+2 : 3]};
                end            
            end
        end
        // ✅ Ensamblado final de las flags
        ALUFlags = {flag_invalid, flag_div_zero, flag_overflow, flag_underflow, flag_inexact};
    end
endmodule
